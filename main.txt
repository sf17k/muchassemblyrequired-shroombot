;;  Options
RUN_TESTS equ 1

;;                         ,-------------------,
;;                         | Hello, my name is |
;;                         |     shroombot     |
;;                         `-------------------'



;;  Table of Contents [toc]
; 0. START
; 1. BEHAVIOR
; 2. DRIVERS
;    - Movement
;    - Display
;    - Sensors
; 3. TESTING
; 4. MATH
; 5. TYPES
;    - Map
; 6. UTILITY



;;  Tips
; Names prefixed with _underscores are implementation details.

;;  Memory layout
; 0x0000 lidar path
; 0x0050 some execution statistics
; 0x0100 lidar map
; 0x0200 the program (.data and .text)



;;  Constants

FALSE equ 0x0000 ; must be 0x0000
TRUE equ 0xffff ; must be 0xffff

; for testing framework
REG_A equ 0x0001
REG_B equ 0x0002
REG_C equ 0x0004
REG_D equ 0x0008
REG_X equ 0x0010
REG_Y equ 0x0020
REG_BP equ 0x0040
REG_SP equ 0x0080

DIR_N equ 0
DIR_E equ 1
DIR_S equ 2
DIR_W equ 3

HW_LEGS equ 0x0001
HW_LIDAR equ 0x0003
HW_RNG equ 0x0007
HW_CLOCK equ 0x0008
HW_HOLO equ 0x0009
HW_BATTERY equ 0x000a

HOLO_CLEAR equ 0
HOLO_DISPLAY_HEX equ 1
HOLO_DISPLAY_STRING equ 2

BATTERY_GET_CHARGE equ 1
BATTERY_GET_CAPACITY equ 2

LEGS_TURN equ 1 ; 20 kJ
LEGS_WALK equ 2 ; 100 kJ

LIDAR_GET_POS equ 1
LIDAR_GET_PATH equ 2 ; 50 kJ
LIDAR_GET_MAP equ 3 ; 10 kJ
LIDAR_GET_WORLD_POS equ 4

LIDAR_PATH_ADDR equ 0x0000
LIDAR_MAP_ADDR equ 0x0100

MAP_SIZE equ 0x0100 ; 16x16

; used by updateMapPeriodically
;MAP_UPDATE_INTERVAL equ 4 ; ticks
;MAP_UPDATE_INTERVAL_MOVING equ 2 ; ticks, for moving targets
MAP_UPDATE_INTERVAL equ 1 ; ticks
MAP_UPDATE_INTERVAL_MOVING equ 1 ; ticks, for moving targets

; bits
MAP_WALL equ 0x8000
MAP_BIOMASS equ 0x4000
MAP_IRON equ 0x0200
MAP_COPPER equ 0x0100
MAP_CUBOT equ 0x0080



;;                                                              0. START
;;  ********************************************************************

.data

debugValue: dw 0 ; printed value

; bot status
facingDir: dw -1 ; -1 means don't know yet



.text

entryPoint:
    ; run tests or main code
    mov a, RUN_TESTS
    cmp a, 0
    jz run
    jmp runAllTests



;;  runAllTests (entry point)

; Runs tests, shows results, and halts.

; Results marked by 0xF00D on success, 0xDEAD on failure.
; Next value is number of passed tests, more details may follow.

runAllTests:
    call _preAllTests
    
    ; --- ALL TESTS ---

    mov [nextTest], count_test1
    call runTest
    mov [nextTest], count_test2
    call runTest
    mov [nextTest], count_test3
    call runTest
    mov [nextTest], count_test4
    call runTest
    mov [nextTest], count_test5
    call runTest
    mov [nextTest], seedRng_test
    call runTest
    mov [nextTest], random_test
    call runTest
    
    ; ^ ADD TESTS HERE ^

    call _postAllTests
    brk



;;  run (entry point)

; Main code. Halts when finished.

run:
    ; cheat
    mov a, -1
    hwi HW_BATTERY
    
    ; commands
    
    call updateMapPeriodically
    mov a, MAP_CUBOT
    call searchMap ; position or (-1,-1) in x,y
    call updateTarget
    
    ; show target x,y
    mov [debugValue], x
    shl [debugValue], 8
    or [debugValue], y
    
    mov a, 0 ; distance, set to 0 to avoid battery usage (FIXME)
    call moveTo
    mov [isStopped], FALSE ; reset
    
    ; if battery full, take a step
    call usedCharge ; in b
    cmp b, 0
    jnz run_endif
    mov a, LEGS_WALK ; walk
    mov b, [facingDir]
    hwi HW_LEGS
    
run_endif:
    ; debug printing
    call displayDebugValues
    brk



;;  displayDebugValues()
;;  corrupt a,b

; TODO function to add a value to an array

displayDebugValues:
    push bp
    mov bp, sp
    
    ; print marker
    ;push 0xC0DE ; marker
    
    ; print values
    push [debugValue]
    
    ; print battery charge used
    call usedCharge
    push b
    
    
    ; numValues = bp - sp
    mov a, bp
    sub a, sp
    
    call marquee
    
    pop bp
    ret



;;                                                           1. BEHAVIOR
;;  ********************************************************************

didMapUpdateThisTick: dw FALSE
lastTargetX: dw -1
lastTargetY: dw -1
isTargetMoving: dw FALSE



;;  updateMapPeriodically()
;;  corrupt all

updateMapPeriodically:
    mov [didMapUpdateThisTick], FALSE
    
    ; modulo clock for periodic updates
    mov c, [isTargetMoving] ; if moving, use interval for moving, else the other one
    mov d, c ; d = ~c
    not d
    and c, MAP_UPDATE_INTERVAL_MOVING ; d = isTargetMoving ? intervalMoving : interval
    and d, MAP_UPDATE_INTERVAL
    or d, c
    
    hwi HW_CLOCK ; time in b:c
    mov y, b ; copy to y:a for modulo
    mov a, c
    div d ; clock % interval, remainder in y
    
    cmp y, 0 ; if remainder is 0, time to update
    jnz updateMapPeriodically_end
    
    ; get map
    mov a, LIDAR_GET_MAP
    hwi HW_LIDAR
    mov [didMapUpdateThisTick], TRUE
    
updateMapPeriodically_end:
    ret



;;  updateMapIfBatteryFull()
;;  corrupt a,b,c

; TODO change to isBatteryFull()

updateMapIfBatteryFull:
    mov a, BATTERY_GET_CHARGE
    hwi HW_BATTERY
    mov c, b
    mov a, BATTERY_GET_CAPACITY
    hwi HW_BATTERY
    cmp c, b ; if not full, return
    jl updateMapIfBatteryFull_end
    
    ; get map
    mov a, LIDAR_GET_MAP
    hwi HW_LIDAR
    
updateMapIfBatteryFull_end:
    ret



;;  updateTarget()
;;  in x,y: newTarget

; Sets lastTargetX, lastTargetY, isTargetMoving.

updateTarget:
    ; only update if map has updated
    cmp [didMapUpdateThisTick], 0
    jz updateTarget_end
    
    ; has target moved?
    cmp [lastTargetX], x
    jnz updateTarget_moved
    cmp [lastTargetY], y
    jnz updateTarget_moved
    
    ; not moved
    mov [isTargetMoving], FALSE
    ret
    
updateTarget_moved:
    mov [isTargetMoving], TRUE
    mov [lastTargetX], x
    mov [lastTargetY], y
    
updateTarget_end:
    ret



;;                                                            2. DRIVERS
;;  ********************************************************************

;;                                                          Movement
;;  ----------------------------------------------------------------

isStopped: dw FALSE ; disable further commands?



;;  stepOnce()
;;  in b: direction
;;  corrupt a

; Manual command to take one step.

stepOnce:
    cmp [isStopped], TRUE ; if isStopped, exit
    jz stepOnce_end
    
    mov a, LEGS_WALK
    hwi HW_LEGS ; direction already in b
    
    mov [isStopped], TRUE ; prevent walking again
    
stepOnce_end:
    ret



;;  stepN()
;;  in a: numSteps
;;  in b: direction
;;  corrupt a,d

; Manual command to take multiple steps in one direction.

stepN_stepsLeft: dw -1 ; -1 means no stepN command started yet

stepN:
    cmp [isStopped], TRUE ; if isStopped, exit
    jz stepN_end
    
    mov d, a ; numSteps
    
    ; take step
    mov a, LEGS_WALK
    hwi HW_LEGS ; direction already in b
    
    ; if stepsLeft not set, set it
    cmp [stepN_stepsLeft], 0
    jge stepN_endif
    mov [stepN_stepsLeft], d ; numSteps
    
stepN_endif:
    ; decrement stepsLeft
    sub [stepN_stepsLeft], 1
    
    ; halt if finished
    cmp [stepN_stepsLeft], 0
    jg stepN_end
    mov [isStopped], TRUE
    
stepN_end:
    ret



;;  faceToward()
;;  in x,y: target
;;  corrupt all

; Costs 20 kJ if need to turn.

faceToward:

    ; put offset from own pos in c,d
    mov c, x ; copy
    mov d, y
    mov a, LIDAR_GET_POS
    hwi HW_LIDAR
    sub c, x ; get offset
    sub d, y
    
    ; put absolute value of offset coords in x,y
    mov x, c ; copy x
    mov a, x ; abs
    sar a, 15
    xor x, a
    sub x, a
    mov y, d ; copy y
    mov a, y ; abs
    sar a, 15
    xor y, a
    sub y, a
    
    ; pick larger dimension
    cmp x, y ; if abs(x) > abs(y), face a horizontal direction, else vertical
    jl faceToward_vertical

faceToward_horizontal:
    mov b, DIR_E ; face east if positive x
    cmp c, 0 ; if negative x, flip to west
    jl faceToward_flip
    jmp faceToward_turn
    
faceToward_vertical:
    mov b, DIR_N ; face north if negative y
    cmp d, 0 ; if positive y, flip to south
    jg faceToward_flip
    jmp faceToward_turn
    
faceToward_flip:
    add b, 2 ; flip compass direction
    
faceToward_turn:
    ; don't turn if already facing
    cmp [facingDir], b
    jz faceToward_end
    
    mov a, LEGS_TURN
    hwi HW_LEGS ; direction already in b
    
    mov [facingDir], b ; save direction
    
faceToward_end:
    ret



;;  moveTo()
;;  in a: distance
;;  in x,y: destination
;;  corrupt all

; Manual command to pathfind and move to destination.
; Costs an extra 50 kJ per pathfind.
; Will not pathfind if destination already reached or outside bounds.

moveTo_pathPtr: dw -1 ; -1 means not started

moveTo:
    push a ; distance
    
    cmp [isStopped], TRUE ; if isStopped, exit
    jz moveTo_end
    
    ; initialize
    jmp moveTo_endif
    
    cmp [moveTo_pathPtr], -1 ; if already started on path, skip initialization
    jnz moveTo_walkPath
    
    ; check destination is valid
    test x, 0xfff0 ; if x or y are not in [0, 16), halt
    jnz moveTo_halt
    test y, 0xfff0
    jnz moveTo_halt
    
    ; check we're not already at destination
    mov c, x ; store x,y
    mov d, y
    mov a, LIDAR_GET_POS
    hwi HW_LIDAR
    
    cmp c, x ; if position == destination, halt
    jnz moveTo_endif
    cmp d, y
    jnz moveTo_endif
    jmp moveTo_halt
    
    ; end initialize
    
moveTo_endif:
    ; calculate path
    mov a, LIDAR_GET_PATH ; pathfind to x,y
    mov b, [sp+0] ; distance
    hwi HW_LIDAR
    
    ; start on path
    mov [moveTo_pathPtr], LIDAR_PATH_ADDR
    
moveTo_walkPath:
    ; read step
    mov b, [moveTo_pathPtr] ; read from path memory
    mov b, [b]
    cmp b, -1 ; halt if invalid
    jz moveTo_halt
    cmp b, 0xAAAA ; halt if reached end (marked by magic number)
    jz moveTo_halt
    
    ; take step
    mov a, LEGS_WALK
    hwi HW_LEGS ; direction is in b
    
    ; advance to next step
    add [moveTo_pathPtr], 1
    
    ; done
    jmp moveTo_end
    
moveTo_halt:
    ; halt
    mov [isStopped], TRUE
    
moveTo_end:
    add sp, 1 ; pop distance
    ret



;;                                                           Display
;;  ----------------------------------------------------------------

;;  marquee(value...)
;;  in a: numValues

; Show values in sequence using hologram.
; Changing numValues will throw off the sequence.

marquee:
    push bp
    mov bp, sp
    push a
    push b
    push c
    push d
    push x
    push y
    
    mov d, a ; numValues
    
    ; calculate index
    hwi HW_CLOCK ; clock in b:c
    mov y, b ; copy to y:a
    mov a, c
    div d ; index in y = clock % numValues
    
    ; show indexed value
    mov b, d ; numValues
    sub b, y ; - index (cuz upside down stack)
    add b, bp ; + bp
    mov b, [b+1] ; + arg offset of 2 - 1 = &value
    mov a, HOLO_DISPLAY_HEX
    hwi HW_HOLO
    
    pop y
    pop x
    pop d
    pop c
    pop b
    pop a
    pop bp
    ret a ; pop args



;;                                                           Sensors
;;  ----------------------------------------------------------------

;;  usedCharge()
;;  out b: capacity - charge

usedCharge:
    push a
    push c

    mov a, BATTERY_GET_CHARGE
    hwi HW_BATTERY
    mov c, b
    mov a, BATTERY_GET_CAPACITY
    hwi HW_BATTERY
    sub b, c

    pop c
    pop a
    ret



;;                                                            3. TESTING
;;  ********************************************************************

; Test functions should be careful not to modify any registers themselves.
; The registers will be set to random values and checked for modification.

; Example assert usages:
;   mov [testExpectedA], 0x1234
;   or [testCorruptRegs], REG_A

; Example test run:
;   mov [nextTest], testMyStuff
;   call runTest


; the test func, i.e. a func whose name ends with "_test"
; which in turn calls the *tested* func(s)
nextTest: dw 0 ; addr

; which registers should we NOT check?
testCorruptRegs: dw 0x0000 ; flags

; which registers failed their checks?
testFailedRegs: dw 0x0000 ; flags

; helps identify which test failed
testNumPassed: dw 0

; asserted values
testExpectedA: dw 0
testExpectedB: dw 0
testExpectedC: dw 0
testExpectedD: dw 0
testExpectedX: dw 0
testExpectedY: dw 0
testExpectedBP: dw 0
testExpectedSP: dw 0

; for error reporting
testActualA: dw 0
testActualB: dw 0
testActualC: dw 0
testActualD: dw 0
testActualX: dw 0
testActualY: dw 0
testActualBP: dw 0
testActualSP: dw 0

; set to prevent running tests more than once
_testsPerformed: dw FALSE



_preAllTests:
    ; if tests finished, show results
    cmp [_testsPerformed], TRUE
    jz _preAllTests_results
    mov [_testsPerformed], TRUE
    
    ; init RNG
    call seedRng
    
    ret
    
_preAllTests_results:
    call _showTestResults
    brk



_postAllTests:
    call _showTestResults
    ret



_showTestResults:
    ; if all passed, show success
    cmp [testFailedRegs], 0x0000
    jz _showTestResults_success
    
    ; show failure
    push 0xDEAD ; marker
    push [testNumPassed]
    push [testFailedRegs]
    push [testActualA]
    push [testActualB]
    push [testActualC]
    push [testActualD]
    push [testActualX]
    push [testActualY]
    mov a, 9 ; numValues
    call marquee
    
    jmp _showTestResults_end
    
_showTestResults_success:
    ; show success
    push 0xF00D ; marker
    push [testNumPassed]
    mov a, 2 ; numValues
    call marquee
    
_showTestResults_end:
    ret



;;  runTest()
;;  in a: testFunc
;;  corrupt all

; Runs testFunc with pre and post tasks.

runTest:
    call _preTest
    call [nextTest]
    call _postTest
    mov [nextTest], 0 ; reset
    ret


_preTest:
    mov [testCorruptRegs], 0x0000

    ; initialize registers with random numbers (except bp, sp)
    call random
    mov [testExpectedA], a
    call random
    mov [testExpectedB], a
    call random
    mov [testExpectedC], a
    call random
    mov [testExpectedD], a
    call random
    mov [testExpectedX], a
    call random
    mov [testExpectedY], a
    mov [testExpectedBP], bp
    mov [testExpectedSP], sp ; sp last

    mov a, [testExpectedA]
    mov b, [testExpectedB]
    mov c, [testExpectedC]
    mov d, [testExpectedD]
    mov x, [testExpectedX]
    mov y, [testExpectedY]

    ret


_postTest:
    ; save all registers
    mov [testActualA], a
    mov [testActualB], b
    mov [testActualC], c
    mov [testActualD], d
    mov [testActualX], x
    mov [testActualY], y
    mov [testActualBP], bp
    mov [testActualSP], sp

    ; check that registers match expected values

    mov [testFailedRegs], 0x0000 ; clear errors
    mov c, [testCorruptRegs]

    ; check register A
    test c, REG_A ; if expected corrupt, pass
    jnz _postTest_endA
    cmp [testActualA], [testExpectedA] ; if actual == expected, pass
    jz _postTest_endA
    or [testFailedRegs], REG_A ; fail
_postTest_endA:
    ; check register B...
    test c, REG_B
    jnz _postTest_endB
    cmp [testActualB], [testExpectedB]
    jz _postTest_endB
    or [testFailedRegs], REG_B
_postTest_endB:
    test c, REG_C
    jnz _postTest_endC
    cmp [testActualC], [testExpectedC]
    jz _postTest_endC
    or [testFailedRegs], REG_C
_postTest_endC:
    test c, REG_D
    jnz _postTest_endD
    cmp [testActualD], [testExpectedD]
    jz _postTest_endD
    or [testFailedRegs], REG_D
_postTest_endD:
    test c, REG_X
    jnz _postTest_endX
    cmp [testActualX], [testExpectedX]
    jz _postTest_endX
    or [testFailedRegs], REG_X
_postTest_endX:
    test c, REG_Y
    jnz _postTest_endY
    cmp [testActualY], [testExpectedY]
    jz _postTest_endY
    or [testFailedRegs], REG_Y
_postTest_endY:
    test c, REG_BP
    jnz _postTest_endBP
    cmp [testActualBP], [testExpectedBP]
    jz _postTest_endBP
    or [testFailedRegs], REG_BP
_postTest_endBP:
    test c, REG_SP
    jnz _postTest_endSP
    cmp [testActualSP], [testExpectedSP]
    jz _postTest_endSP
    or [testFailedRegs], REG_SP
_postTest_endSP:

    ; if all passed, move on
    cmp [testFailedRegs], 0x0000
    jz _postTest_end

    ; else show error and halt
    call _showTestResults
    brk ; halt

_postTest_end:
    add [testNumPassed], 1 ; won't reach this if failed
    ret



;;                                                               4. MATH
;;  ********************************************************************

_rngState: dw 0x5837 ; randomly chosen initial value



;;  seedRng()

; Seed RNG using hardware RNG, at small energy cost.

seedRng:
    push b
    hwi HW_RNG
    mov [_rngState], b
    pop b
    ret

;;  TEST
seedRng_test:
    call seedRng
    ret



;;  random()
;;  out a: result

; Returns random word without relying on hardware RNG.
; http://www.retroprogramming.com/2017/07/xorshift-pseudorandom-numbers-in-z80.html

random:
    push b
    mov a, [_rngState]
    mov b, a ; xs ^= xs << 7
    shl b, 7
    xor a, b
    mov b, a ; xs ^= xs >> 9
    shr b, 9
    xor a, b
    mov b, a ; xs ^= xs << 8
    shl b, 8
    xor a, b
    mov [_rngState], a
    pop b
    ret

;;  TEST
random_test:
    or [testCorruptRegs], REG_A ; result is random, can't predict it
    call random
    ret



;;                                                              5. TYPES
;;  ********************************************************************

;;                                                               Map
;;  ----------------------------------------------------------------

;;  searchMap()
;;  in a: item to search for
;;  out x,y: position or (-1,-1)
;;  corrupt all

; Searches the map that's in memory, so make sure it's up to date.
; Ignores own position.

searchMap:
    push a ; item
    
    ; index of own position, so we can skip it
    ; (in case we're searching for cubots)
    mov a, LIDAR_GET_POS
    hwi HW_LIDAR
    call mapXYToIndex
    mov b, a ; ownIndex
    add b, LIDAR_MAP_ADDR
    
    ; search map for item
    pop a ; value = item
    mov c, LIDAR_MAP_ADDR ; startAddr
    mov d, c
    add d, MAP_SIZE ; endAddr
    
searchMap_loop:
    ; search
    call findNext ; out c
    
    ; if found own position, keep searching
    cmp c, b
    jnz searchMap_finishedSearch
    add c, 1 ; skip this position
    jmp searchMap_loop

searchMap_finishedSearch:
    cmp c, d ; if not found, return (-1, -1)
    jz searchMap_fail
    
    ; index = resultAddr - startAddr
    mov a, c
    sub a, LIDAR_MAP_ADDR
    
    ; return x,y
    call mapIndexToXY
    jmp searchMap_end
    
searchMap_fail:
    mov x, -1
    mov y, -1

searchMap_end:
    ret



;;  mapXYToIndex()
;;  in x,y: coords
;;  out a: index in [0, MAP_SIZE), i.e. a byte

mapXYToIndex:
    ; index bits are 0000 0000 yyyy xxxx
    mov a, y
    shl a, 4
    or a, x
    ret



;;  mapIndexToXY()
;;  in a: index in [0, MAP_SIZE), i.e. a byte
;;  out x,y: coords

mapIndexToXY:
    ; index bits are 0000 0000 yyyy xxxx
    mov x, a
    and x, 0x000f
    
    mov y, a
    shr y, 4
    and y, 0x000f
    ret



;;                                                            6. UTILITY
;;  ********************************************************************

;;  findNth()
;;  in a: value
;;  in b: N
;;  in c: startAddr
;;  in d: endAddr
;;  out c: result or endAddr
;;  corrupt b

; Search memory sequentially for Nth occurrence of value,
; where the first occurrence is the 0th.
; Return address of Nth occurrence, or endAddr if not found.
; endAddr is one past last item to be searched.

findNth:
    ; start loop
    cmp c, d ; if reached end, return
    jge findNth_end
    
    call findNext ; find next occurrence
    
    cmp b, 0 ; if searched N times, return
    jz findNth_end
    
    sub b, 1 ; advance
    jmp findNth ; loop
    
findNth_end:
    ret



;;  findNext()
;;  in a: value
;;  in c: startAddr
;;  in d: endAddr
;;  out c: result or endAddr

; Search memory sequentially for value.
; Return address of first occurrence, or endAddr if not found.
; endAddr is one past last item to be searched.

findNext:
    ; start loop
    cmp c, d ; if reached end, return
    jge findNext_end
    
    cmp a, [c] ; if found value, return
    jz findNext_end
    
    add c, 1 ; advance
    jmp findNext ; loop
    
findNext_end:
    ret



;;  count()
;;  in a: value
;;  in c: startAddr
;;  in d: endAddr
;;  out b: count

; Search memory region for value, count number of occurrences.
; endAddr is one past last item to be searched.

count:
    push c
    mov b, 0 ; counter
    
count_loop:
    ; start loop
    cmp c, d ; if reached end, return
    jge count_end
    
    cmp a, [c] ; if found value, increment counter
    jnz count_next
    add b, 1
    
count_next:
    add c, 1 ; advance
    jmp count_loop ; loop
    
count_end:
    pop c
    ret

;;  TEST
count_test_data: dw 55,33,11,22,33,44,44,44,44,55,33,22,55,55,55
count_test_dataEnd: dw -1
;;  in a: value
count_test_helper:
    ; startAddr
    mov c, count_test_data
    ; endAddr
    mov d, count_test_dataEnd
    
    mov [testExpectedA], a
    mov [testExpectedC], c
    mov [testExpectedD], d

    call count
    ret
    
count_test1:
    ; the value 11 shows up 1 time in test_data
    mov a, 11
    mov [testExpectedB], 1
    jmp count_test_helper
count_test2:
    mov a, 22
    mov [testExpectedB], 2
    jmp count_test_helper
count_test3:
    mov a, 33
    mov [testExpectedB], 3
    jmp count_test_helper
count_test4:
    mov a, 44
    mov [testExpectedB], 4
    jmp count_test_helper
count_test5:
    mov a, 55
    mov [testExpectedB], 5
    jmp count_test_helper



